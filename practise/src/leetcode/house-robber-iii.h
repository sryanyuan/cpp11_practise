#ifndef _INC_HOUSE_ROBBER_III_
#define _INC_HOUSE_ROBBER_III_

#include "_common_all.h"
#include "_common_list.h"
#include "_common_binary_tree.h"

/* Generated by leetgen (github.com/sryanyuan/leetgen)

The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night.



Determine the maximum amount of money the thief can rob tonight without alerting the police.


Example 1:

     3
    / \
   2   3
    \   \ 
     3   1

Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.


Example 2:

     3
    / \
   4   5
  / \   \ 
 1   3   1

Maximum amount of money the thief can rob = 4 + 5 = 9.


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.*/

class HouseRobberIii : public TreeNodeCls {
public:
	static void test() {
		auto t = stringToTreeNode("[3,2,3,null,3,null,1]");
        auto res = rob(t);
	}

	static int rob(TreeNode* root) {
        if (nullptr == root) {return 0;}
		int maxRob = 0;
        vector<int> dps0;
        vector<int> dps1;
        vector<TreeNode *> pnodes(1, root);
        while (!pnodes.empty()) {
            bool allNull = true;
            for (auto n : pnodes) {
                if (n != nullptr) {
                    allNull = false;
                }
            }
            if (allNull) {
                break;
            }
            vector<TreeNode *> cnodes;
            vector<int> cdps;
            int ni = 0;
            for (auto node : pnodes) {
                TreeNode *left = nullptr;
                TreeNode *right = nullptr;
                int ndp = 0;
                if (nullptr != node) {
                    left = node->left;
                    right = node->right;
                    // Get parent and grand parent index
                    int pi = (ni - 1) / 2;
                    int gi = (pi - 1) / 2;
                    int dpp = (pi >= 0 && pi < dps1.size()) ? dps1[pi] : 0;
                    int dpg = (gi >= 0 && gi < dps0.size()) ? dps0[gi] + node->val : node->val;
                    ndp = std::max(dpp, dpg);
                    maxRob = std::max(maxRob, ndp);
                }
                cnodes.push_back(left);
                cnodes.push_back(right);
                cdps.push_back(ndp);
                ++ni;
            }
            pnodes = std::move(cnodes);
            dps0 = std::move(dps1);
            dps1 = std::move(cdps);
        }
        return maxRob;
	}
};

#endif
