#ifndef _INC_MINIMUM_PATH_SUM_
#define _INC_MINIMUM_PATH_SUM_

#include "_common_all.h"
#include "_common_list.h"
#include "_common_binary_tree.h"

/* Generated by leetgen (github.com/sryanyuan/leetgen)
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:


Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.

*/

class MinimumPathSum {
public:
	static void test() {
		
	}

	static int minPathSum(vector<vector<int>>& grid) {
		int minCost = 0;
        int n = grid.size();
        int m = grid[0].size();
        int *costs = new int[m * n];
        for (int i = 0; i < m * n; i++) {
            costs[i] = 0;
        }
        costs[0] = grid[0][0];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (i == 0 && j == 0) {continue;}
                int upv = INT_MAX, leftv = INT_MAX;
                if (i - 1 >= 0) {
                    upv = costs[(i - 1) * m + j];
                }
                if (j - 1 >= 0) {
                    leftv = costs[i * m + j - 1];
                }
                int cost = upv < leftv ? upv + grid[i][j] : leftv + grid[i][j];
                costs[i * m + j] = cost;
            }
        }
        minCost = costs[m * n - 1];
        delete[] costs;
        return minCost;
	}
};

#endif
