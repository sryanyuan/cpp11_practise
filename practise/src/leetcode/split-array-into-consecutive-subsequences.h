#ifndef _INC_SPLIT_ARRAY_INTO_CONSECUTIVE_SUBSEQUENCES_
#define _INC_SPLIT_ARRAY_INTO_CONSECUTIVE_SUBSEQUENCES_

#include "_common_all.h"
#include "_common_list.h"
#include "_common_binary_tree.h"

/* Generated by leetgen (github.com/sryanyuan/leetgen)
You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split.

Example 1:

Input: [1,2,3,3,4,5]
Output: True
Explanation:
You can split them into two consecutive subsequences : 
1, 2, 3
3, 4, 5



Example 2:

Input: [1,2,3,3,4,4,5,5]
Output: True
Explanation:
You can split them into two consecutive subsequences : 
1, 2, 3, 4, 5
3, 4, 5



Example 3:

Input: [1,2,3,4,4,5]
Output: False



Note:

The length of the input is in range of [1, 10000]

*/

class SplitArrayIntoConsecutiveSubsequences {
public:
	static void test() {
		int ar[] = {1,2,3,3,4,4,5,5};
        vector<int> nums(ar, ar + sizeof(ar) / sizeof(ar[0]));
        auto res = isPossible(nums);
	}

    static bool isPossible(vector<int>& nums) {
        unordered_map<int, list<int> > numsMap;
        for (auto v : nums) {
            auto fit = numsMap.find(v - 1);
            if (fit == numsMap.end()) {
                // In no list, add to self counter list
                fit = numsMap.find(v);
                if (fit == numsMap.end()) {
                    list<int> nlist;
                    nlist.push_back(1);
                    numsMap.insert(std::make_pair(v, std::move(nlist)));
                } else {
                    fit->second.push_back(1);
                }
                continue;
            }
            // Find the min counter and increase the map key
            list<int>::iterator itMin = fit->second.end();
            for (auto it = fit->second.begin();
                it != fit->second.end();
                ++it) {
                    if (itMin == fit->second.end() || *itMin > *it) {
                        itMin = it;
                    }
            }
            // Erase the iterator and add a count to next val
            int nextCounter = 1;
            if (itMin != fit->second.end()) {
                nextCounter = *itMin + 1;
                fit->second.erase(itMin);
            }
            // Add to next counter list
            fit = numsMap.find(v);
            if (fit == numsMap.end()) {
                list<int> nlist;
                nlist.push_back(nextCounter);
                numsMap.insert(std::make_pair(v, std::move(nlist)));
            } else {
                fit->second.push_back(nextCounter);
            }
        }
        // Check all counters
        for (auto &pr : numsMap) {
            for (auto v : pr.second) {
                if (v < 3) {
                    return false;
                }
            }
        }
        return true;
	}
};

#endif
