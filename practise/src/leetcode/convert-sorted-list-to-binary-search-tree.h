#ifndef _INC_CONVERT_SORTED_LIST_TO_BINARY_SEARCH_TREE_
#define _INC_CONVERT_SORTED_LIST_TO_BINARY_SEARCH_TREE_

#include "_common_all.h"
#include "_common_list.h"
#include "_common_binary_tree.h"

/* Generated by leetgen (github.com/sryanyuan/leetgen)
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:


Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5

*/

class ConvertSortedListToBinarySearchTree : public TreeNodeCls, public SingleLinkedListCls {
public:
	static void test() {
		auto res = sortedListToBST(stringToListNode("[-10,-3,0,5,9]"));
	}

	static TreeNode* sortedListToBST(ListNode* head) {
        if (nullptr == head) {return nullptr;}
		return build(head, nullptr, nullptr, false); 
	}

    static TreeNode * build(ListNode *head, ListNode *tail, TreeNode *parent, bool left) {
        ListNode *fast = head;
        ListNode *slow = head;
        while (fast->next != tail && fast->next->next != tail) {
            slow = slow->next;
            fast = fast->next->next;
        }
        if (nullptr == parent) {
            parent = new TreeNode(slow->val);
        } else {
            if (left) {
                parent->left = new TreeNode(slow->val);
                parent = parent->left;
            } else {
                parent->right = new TreeNode(slow->val);
                parent = parent->right;
            }
        }
        if (slow != head) {
            build(head, slow, parent, true);
        }
        if (slow->next != tail) {
            build(slow->next, tail, parent, false);
        }

        return parent;
    }
};

#endif
