#ifndef _INC_CONSTRUCT_BINARY_TREE_FROM_INORDER_AND_POSTORDER_TRAVERSAL_
#define _INC_CONSTRUCT_BINARY_TREE_FROM_INORDER_AND_POSTORDER_TRAVERSAL_

#include "_common_all.h"
#include "_common_list.h"
#include "_common_binary_tree.h"

/* Generated by leetgen (github.com/sryanyuan/leetgen)
Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given


inorder =Â [9,3,15,20,7]
postorder = [9,15,7,20,3]

Return the following binary tree:


    3
   / \
  9  20
    /  \
   15   7

*/

class ConstructBinaryTreeFromInorderAndPostorderTraversal : public TreeNodeCls {
public:
	static void test() {
        int postvals[] = {9,15,7,20,3};
        vector<int> postorder(postvals, postvals + sizeof(postvals) / sizeof(postvals[0]));
        int invals[] = {9, 3, 15, 20, 7};
        vector<int> inorder(invals, invals + sizeof(invals) / sizeof(invals[0]));
        auto ret = buildTree(inorder, postorder);
	}

	static TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.empty() || inorder.size() != postorder.size()) {
            return nullptr;
        }
		unordered_map<int, int> imp;
        for (int i = 0; i < inorder.size(); i++) {
            imp[inorder[i]] = i;
        }
        return build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1, nullptr, false, imp);
	}

    static TreeNode* build(vector<int> &inorder, int is, int ie, vector<int> &postorder, int ps, int pe, TreeNode *parent, bool left, unordered_map<int, int> &imp) {
        TreeNode *pnode = parent;
        if (nullptr == parent) {
            pnode = new TreeNode(postorder[pe]);
        } else {
            pnode = new TreeNode(postorder[pe]);
            if (left) {
                parent->left = pnode;
            } else {
                parent->right = pnode;
            }
        }
        if (pe == ps) {
            return pnode;
        }
        int rootIndex = imp[postorder[pe]];
        if (is < rootIndex) {
            build(inorder, is, rootIndex - 1, postorder, ps, ps + rootIndex - is - 1, pnode, true, imp);
        }
        if (ie > rootIndex) {
            build(inorder, rootIndex + 1, ie, postorder, pe - 1 - (ie - rootIndex - 1), pe - 1, pnode, false, imp);
        }
        return pnode;
    }
};

#endif
