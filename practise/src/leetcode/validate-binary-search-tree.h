#ifndef _INC_VALIDATE_BINARY_SEARCH_TREE_
#define _INC_VALIDATE_BINARY_SEARCH_TREE_

#include "_common_all.h"
#include "_common_list.h"
#include "_common_binary_tree.h"

/* Generated by leetgen (github.com/sryanyuan/leetgen)
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:


	The left subtree of a node contains only nodes with keys less than the node's key.
	The right subtree of a node contains only nodes with keys greater than the node's key.
	Both the left and right subtrees must also be binary search trees.


Example 1:


Input:
    2
   / \
  1   3
Output: true


Example 2:


    5
   / \
  1   4
     / \
    3   6
Output: false
Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
             is 5 but its right child's value is 4.

*/

class ValidateBinarySearchTree : public TreeNodeCls {
public:
	static void test() {
		
	}

	static bool isValidBST(TreeNode* root) {
		bool res = true;
        dfscp(root, res);
        return res;
	}

    static bool inorder(TreeNode *root) {
        vector<int> nums;
        bool res = true;
        dfs(root, nums, res);
        /*if (nums.size() == 1) {
            return true;
        }
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i - 1] >= nums[i]) {
                return false;
            }
        }*/
        return res;
    }

    static void dfs(TreeNode *node, vector<int> &nums, bool &res) {
        if (nullptr == node) {
            return;
        }
        if (!res) {
            return;
        }
        dfs(node->left, nums, res);
        if (!nums.empty()) {
            if (node->val <= nums.back()) {
                res = false;
                return;
            }
        }
        nums.push_back(node->val);
        dfs(node->right, nums, res);
    }

    static void dfscp(TreeNode *node, bool &res) {
        if (nullptr == node) {
            return;
        }
        if (!res) {
            return;
        }
        if (nullptr != node->left) {
            if (node->left->val >= node->val) {
                res = false;
                return;
            }
            dfscp(node->left, res);
        }
        if (nullptr != node->right) {
            if (node->right->val <= node->val) {
                res = false;
                return;
            }
            dfscp(node->right, res);
        }
    }
};

#endif
