#ifndef _INC_RECONSTRUCT_ITINERARY_
#define _INC_RECONSTRUCT_ITINERARY_

#include "_common_all.h"
#include "_common_list.h"
#include "_common_binary_tree.h"

/* Generated by leetgen (github.com/sryanyuan/leetgen)
Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.

Note:


	If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"].
	All airports are represented by three capital letters (IATA code).
	You may assume all tickets form at least one valid itinerary.


Example 1:


Input: tickets = [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]


Example 2:


Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"]. But it is larger in lexical order.

*/

class ReconstructItinerary {
public:
	static void test() {
		
	}

	static vector<string> findItinerary(vector<pair<string, string>> tickets) {
        vector<string> res;
        unordered_map<string, vector<string>> smap;
        for (auto &pa : tickets) {
            auto it = smap.find(pa.first);
            if (it == smap.end()) {
                vector<string> dests(1, pa.second);
                smap.insert(std::make_pair(pa.first, std::move(dests)));
            } else {
                it->second.push_back(pa.second);
            }
        }
        for (auto &pa : smap) {
            std::sort(pa.second.begin(), pa.second.end());
        }
        res.clear();
        string start = "JFK";
        res.push_back("JFK");
        while (!start.empty()) {
            auto it = smap.find(start);
            if (it == smap.end()) {
                break;
            }
            start.clear();
            for (auto &v : it->second) {
                if (!v.empty()) {
                    start = v;
                    v.clear();
                    res.push_back(start);
                    break;
                }
            }
        }
        return res;
	}
};

#endif
