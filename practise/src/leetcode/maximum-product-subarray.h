#ifndef _INC_MAXIMUM_PRODUCT_SUBARRAY_
#define _INC_MAXIMUM_PRODUCT_SUBARRAY_

#include "_common_all.h"
#include "_common_list.h"
#include "_common_binary_tree.h"

/* Generated by leetgen (github.com/sryanyuan/leetgen)
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:


Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.


Example 2:


Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
*/

class MaximumProductSubarray {
public:
	static void test() {
		
	}

	static int maxProduct(vector<int>& nums) {
		if (nums.empty()) {
            return 0;
        }
        vector<int> minVals(nums.size(), 0);
        vector<int> maxVals(nums.size(), 0);
        minVals[0] = nums[0];
        maxVals[0] = nums[0];
        int maxVal = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            int v1 = nums[i];
            int v2 = minVals[i - 1] * v1;
            int v3 = maxVals[i - 1] * v1;
            minVals[i] = std::min(v1, v2);
            minVals[i] = std::min(minVals[i], v3);
            maxVals[i] = std::max(v1, v2);
            maxVals[i] = std::max(maxVals[i], v3);
            if (maxVals[i] > maxVal) {
                maxVal = maxVals[i];
            }
        }
        return maxVal;
	}

    static int maxProduct2Vals(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        int prevMin = nums[0];
        int prevMax = nums[0];
        int maxVal = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            int v1 = nums[i];
            int v2 = prevMin * v1;
            int v3 = prevMax * v1;
            prevMin = std::min(v1, v2);
            prevMin = std::min(prevMin, v3);
            prevMax = std::max(v1, v2);
            prevMax = std::max(prevMax, v3);
            if (prevMax > maxVal) {
                maxVal = prevMax;
            }
        }
        return maxVal;
    }
};

#endif
